<section id="request">
    <title>Apache Child Processes Lifecycle and Request Processing</title>

    <simplesect>
    	<title>Apache Child Process Lifecycle</title>
	    <para>
	    	HTTP requests are served by child processes spwaned by the 
	    	webserver at start up. The number of child processes created
	    	can be controlled in the Apache configuration and the optimum in the choice
	    	of this number largely depends on the webserver workload and on the system
	    	resources available. See
	    	<ulink url="http://httpd.apache.org/docs/2.2/misc/perf-tuning.html">Apache
	    	documentation</ulink> for further reading about this crucial point. 
	    	Each of the child process is set up to respond to requests
	    	that will come from the network accordingly to the configuration 
	    	parameters. If your webserver has been properly configured you will have Tcl 
	    	scripts being executed (Rivet templates go through a parser before execution)
	    	when requests are sent to the server. 
	    	Your web applications will be doing much of their work doing this job of
	    	responding to requests by creating content to be sent back to a client.
	    </para>
	    <para>
	    	There are 4 stages in the life of an Apache webserver that are relevant
	    	to Rivet: 
	    </para>
	    <orderedlist>
	    	<listitem>
	    		<bridgehead>Single Process Initialization</bridgehead>
	    		<para>
		    		After Apache has parsed the configuration file, before it
		    		spawns the child processes, the webserver is still
		    		a single process application. This stage has a hook in Rivet
		    		which does some check and initialization before the server 
		    		becomes really operational. In this phase 
		    		a configured <command>ServerInitScript</command> (if defined)
		    		is run just after Rivet has created and initialized the master 
		    		interpreter, a Tcl_Interp instance from which child process 
		    		interpreters will be created by copy. <command>ServerInitScript</command>
		    		is a good place to do global initialization that doesn't involve
		    		creation of private data. Example of tasks that can be done
		    		in this context are importing namespace commands, loading packages
		    		providing code of general interest for your application, etc.
	    		</para>
	    	</listitem>
	    	<listitem>
	    		<bridgehead>Child Process Initialization</bridgehead>
	    		<para>
		    		Right after the webserver has created the child processes that are 
		    		to become the real "servers", there is a chance to perform specific 
		    		initialization of the interpreter. This is the stage where most 
		    		likely you want to open I/O channels, database connections or any other
		    		resource that has to be private to the interpreter.
		    		When the option <command>SeparateVirtualInterps</command> is turned off 
		    		child processes will have a single interpreter to serve requests regardless
		    		the name of the virtual host they're aimed at. This interpreter has a
		    		<command>GlobalInitScript</command> directive as initialization script.
	    		</para>
	    		<para>
	    			When <command>SeparateVirtualInterps</command> is turned on 
	    			each configured virtual host will have its own slave interpreter.
	    			<command>ChildInitScript</command> is the directive to be
	    			placed within a &lt;VirtualHost ...&gt; ... &lt;/VirtualHost ...&gt;.
	    			<command>GlobalInitScript</command> has no effect to working interpreters
	    			when this flag is set.
	    		</para>
	    	</listitem>
	    	<listitem>
	    		<bridgehead>Request Processing and Content Generation</bridgehead>
	    		<para>
		   		After a child has been initialized it's ready to serve requests. 
		   		A child process' life is spent almost completely in this phase, waiting
		   		for connections and responding to requests. At every request the URL 
		   		goes through the usual processing and in case rewritten by metadata manipulators
		   		(mod_rewrite, Alias directives, etc), 
		   		variables passed to the webserver are made available to the 
		   		environment and finally the script encoded in the URL is run. 
		   		The requested script execution can be preceded by a configured 
		   		<command>BeforeScript</command> and followed by an
		   		<command>AfterScript</command>. Actually the real script executed is 
		   		internally built by plain concatenation of the <command>BeforeScript</command>,
		   		the script encoded in the URL and the <command>AfterScript</command>.
		   		Thus the whole collection of scripts that make up a web application usually
		   		have the same "before" and "after" scripts to which 
		   		the programmer can devolve tasks common to every page 
		   		(they can access to request variables and environment so that
		   		they can modulate their execution flow and changing it depending on 
					specific parameters) 
	   		</para>
	   	</listitem>
	   	<listitem>
	   		<bridgehead>Child Process Exit</bridgehead>
	   		<para>
		   		If no error condition forces the child process to a premature exit, his
		   		life is determined by the configuration parameters. To avoid problems with
		   		buggy applications the Apache webserver forces a child process to exit after a
		   		certain number of requests served and replaces it with a brand new 
		   		child process. Before the process quits an exit handler can be run
		   		to do some housekeeping, just in case something the could have been 
		   		left behind has to be cleaned up. Like the initialization scripts
		   		<command>ChildExitScript</command> too is a "one shot" script.
	   		</para>
	   	</listitem>
	    </orderedlist>
	</simplesect>
	<simplesect>
    	<title>Apache Rivet Error and Exception Scripts Directives</title>
	   <para>
	    	Rivet is highly configurable and each of the webserver lifecycle stages 
	    	can be exploited to control a web application. 
	    	Not only the orderly sequence of stages
	    	in a child request cycle can be controlled with Tcl scripts, but also
	    	Tcl error conditions or abnormal conditions taking place during
	    	the content generation can be caught and handled with specific scripts
		</para>
	   <para>
	    	Tcl errors (conditions generated when a commands exits with code TCL_ERROR) 
	    	usually result in the printing of a backtrace that shows the code fragment 
	    	relevant to the error occurred.
	    	Rivet configuration can set up scripts to trap these errors and instead run
	    	an <command>ErrorScript</command> to handle the error and conceal details
	    	of the code that usually have no interest for the end user and
	    	may show part of the code that ought to remain private. The ErrorScript
	    	handler might be used to create a polite and nifty error page where things
	    	can be explained in human readable form and can help the user to provide you
	    	with feedback information. 
	    </para>
	    <para>
	    	In other cases an unmanageable conditions might take place in the data and
	    	this could demand a sudden interruption of the page request. These abort 
	    	conditions can be fired by the <xref linkend="abort_page"/> command which
	    	in turn fires the execution of an <command>AbortScript</command> to handle
	    	the abnormal execution. Starting with Rivet 2.1.0 <xref linkend="abort_page"/>
	    	accepts a free form parameter that can be retrieved later with the command 
	    	<xref linkend="abort_code"/>
	    </para>
	</simplesect>
	<simplesect>
		<title>Tcl Namespaces in Rivet and the <command>::request</command> Namespace</title>
		<para>
			Rivet runs pure Tcl scripts at the global namespace. That means that
			every variable or procedure created in Tcl scripts resides by default in the 
			"::" namespace (just like in traditional Tcl scripting) and they
			are persistent across different requests until explicitly unset or
			until the interpreter is deleted (causing the child process to exit).
			You can create your own application namespaces to store data but
			it is important to remember that subsequent requests will in general be served 
			by different child processes. Your application can rely on the fact that 
			certain application data will be in the interpreter, but you shouldn't 
			assume that the state of a transaction spanning several pages 
			can be saved in this way and be safely available to a specific client. 
			Sessions exist for this purpose and Rivet ships its own 
			session package with support for most of popular DBMS. 
			Storing data in the global namespace can be useful (and even then scoping 
			in an application namespace is recommended) when it comes to I/O channel,
			database connection which are usually specific to a process or other 
			information common to the whole application and without privacy
			relevance.
		</para>
		<para>
			A special role in the interpreter is played by the <command>::request</command> 
			namespace.	The <command>::request</command> namespace is deleted and recreated
			at every request and Rivet templates (.rvt files) are executed within it. So,
			unless you're fully qualifying variable names outside the <command>::request</command> 
			namespace, every variable and procedure created in .rvt files is by default place in
			it and deleted before any other requests gets processed. It is therefore safe to
			create variables or object instances in template files and foresake about them: Rivet
			will take care of cleaning the namespace up and everything created inside the namespace
			is so destroyed.
		</para>
		<table id="namespaces">
			<thead>
				<td>Stage</td><td>Script</td><td>Namespace</td>
			</thead>
			<tbody>
				<tr class="init"><td>Apache Initialization</td><td>ServerInitScript</td><td>::</td></tr>
				<tr class="childinit"><td rowspan="2">Child Initialization</td><td>GlobalInitScript</td><td>::</td></tr>
				<tr class="childinit"><td>ChildInitScript</td><td>::</td></tr>
				<tr class="processing"><td rowspan="5">Request Processing</td><td>BeforeScript</td><td>::</td></tr>
				<tr class="processing"><td>.rvt</td><td>::request</td></tr>
				<tr class="processing"><td>.tcl</td><td>::</td></tr>
				<tr class="processing"><td>AfterScript</td><td>::</td></tr>
				<tr class="processing"><td>AfterEveryScript</td><td>::</td></tr>
				<tr class="childexit"><td>Child Exit</td><td>ChildExitScript</td><td>::</td></tr>
			</tbody>
		</table>
	</simplesect>
</section>
