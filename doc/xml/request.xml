<section id="request">
    <title>Apache Child Processes Lifecycle and Request Processing</title>

    <simplesect>
    	<title>Apache Child Process Lifecycle</title>
	    <para>
	    	HTTP requests are served by child processes spwaned by the 
	    	webserver at start up. The number of child processes created
	    	can be controlled in the Apache configuration and the optimum in the choice
	    	of this number largely depends on the webserver workload and on the system
	    	resources available. See
	    	<ulink href="http://httpd.apache.org/docs/2.2/misc/perf-tuning.html">Apache
	    	documentation</ulink> for further reading about this crucial point. 
	    	Each of the child process is set up to respond to requests
	    	that will come from the network accordingly to the configuration 
	    	parameters. If your webserver has been properly configured you will have Tcl 
	    	scripts being run and Rivet templates being parsed and executed after
	    	specific requests have been sent to the server. This is going to be the 
	    	time when your web application will be doing much of its work 
	    	creating content to be sent as output to the client.
	    </para>
	    <para>
	    	There are 4 stages in the life of an Apache webserver that are relevant
	    	to Rivet: 
	    </para>
	    <orderedlist>
	    	<listitem>
	    		<bridgehead>Single Process Initialization</bridgehead>
	    		<para>
		    		After the configuration has been read and parsed but before Apache
		    		spawns the child processes the webserver is still
		    		a single process application. In this phase 
		    		a configured <command>ServerInitScript</command> is run just after Rivet
		    		has created and initialized the master interpreter, a Tcl_Interp 
		    		instance from which child processes interpreters will be created by
		    		copy. 
	    		</para>
	    	</listitem>
	    	<listitem>
	    		<bridgehead>Child Process Initialization</bridgehead>
	    		<para>
		    		Right after the webserver has created the child processes that are 
		    		to become the real "servers", there is a chance to perform specific 
		    		initialization of the interpreter. This is the stage where most 
		    		likely you want to open I/O channels, database connections or any other
		    		resource that has to be private to the interpreter.
		    		When the option <command>SeparateVirtualInterps</command> is turned off 
		    		child processes will have a single interpreter to serve requests regardless
		    		the name of the virtual host they're aimed at. This interpreter as a
		    		<command>GlobalInitScript</command> directive for the initialization code.
	    		</para>
	    		<para>
	    			When <command>SeparateVirtualInterps</command> is turned on 
	    			each configured virtual host will have its own slave interpreter.
	    			<command>ChildInitScript</command> is the directive to be
	    			placed within a &lt;VirtualHost ...&gt; ... &lt;/VirtualHost ...&gt;.
	    			<command>GlobalInitScript</command> has no effect to working interpreters
	    			when this flag is set.
	    		</para>
	    	</listitem>
	    	<listitem>
	    		<bridgehead>Request Processing and Content Generation</bridgehead>
	    		<para>
		   		After a child has been initialized it's ready to serve requests. 
		   		The child process life is spent almost completely in this phase, waiting
		   		for connections and responding to requests. At every request the URL 
		   		goes through the usual processing and in case rewritten by metadata manipulators, 
		   		variables passed to the webserver are made available to the 
		   		environment and finally the script coded in the URL is run. 
		   		The requested script execution can be preceded by a configured 
		   		<command>BeforeScript</command> and followed by a 
		   		<command>AfterScript</command>. Actually the real script executed is 
		   		internally built by the concatenation of the <command>BeforeScript</command>,
		   		the script encoded in the URL and the <command>AfterScript</command>.
		   		Thus the whole collection of scripts that make up a web application usually
		   		have the same "before" and "after" scripts to which 
		   		the programmer can devolve tasks common to every page 
		   		(they can access to request variables and environment so that
		   		they can modulate their execution flow and changing it depending on 
					specific parameters) 
	   		</para>
	   	</listitem>
	   	<listitem>
	   		<bridgehead>Child Process Exit</bridgehead>
	   		<para>
		   		If no error condition forces the child process to a premature exit, his
		   		life is determined by the configuration parameters. To avoid problems with
		   		buggy applications the Apache webserver forces a child process to exit after a
		   		certain number of requests served and replaces it with a brand new 
		   		child process. Before the process quits an exit handler can be run
		   		to do some housekeeping, just in case something the could have been 
		   		left behind has to be cleaned up. Like the initialization scripts
		   		<command>ChildExitScript</command> too is a "one shot" script.
	   		</para>
	   	</listitem>
	    </orderedlist>
	</simplesect>
	<simplesect>
    	<title>Apache Rivet Error and Exception Scripts Directives</title>
	   <para>
	    	Rivet is highly configurable and each of the stages can be exploited
	    	to control a web application. Not only the orderly sequence of stages
	    	in the child process cycle can be controlled with Tcl scripts, but also
	    	Tcl error conditions or abnormal conditions that can take place during
	    	the content generation can be caught and handled with specific scripts
		</para>
	   <para>
	    	Tcl errors usually result in the printing of
	    	a backtrace that shows the code fragment relevant to the error occurred.
	    	Rivet configuration can set up scripts to trap these errors and instead run
	    	an <command>ErrorScript</command> to handle the error and conceal details
	    	of the code that usually have no interest for the end user and
	    	can expose details of the code that ought to remain private. The error
	    	condition might be used to create a polite and nifty error page where things
	    	can be explained in order to have a feedback from the user. 
	    </para>
	    <para>
	    	In other cases an unmanageable conditions might take place in the data and
	    	this could demand a sudden interruption of the page request. These abort 
	    	conditions can be fired by the <xref linkend="abort_page"/> command which
	    	in turn fires the execution of an <command>AbortScript</command> to handle
	    	the abnormal execution.
	    </para>
	</simplesect>
	<simplesect>
		<title>Tcl Namespaces in Rivet and the <command>::request</command> Namespace</title>
		<para>
			Rivet run pure Tcl scripts at the global namespace. That means that
			every variable or procedure resides by default in the "::" namespace and they
			are persistent across different requests until they are explicitly unset or
			the interpreter is deleted.
			You can create your own application namespaces to store data but
			it is important to remember that subsequent requests will in general be served 
			by different child processes. Your application can rely on the fact that 
			certain application data will be in the interpreter, but you shouldn't 
			assume that a transaction state can be saved in this way and be safely available to 
			a specific client. Sessions are for this purpose and Rivet ships its own 
			<xref href="session_package" /> with support for most of popular DBMS. 
			Storing data in the global namespace can be useful (and even then scoping 
			in an application namespace is recommended) when it comes to I/O channel
			or database connection which are usually specific to a process.
		</para>
		<para>
			A special role in the interpreter is played by the <command>::request</command> 
			namespace.	The <command>::request</command> namespace is deleted and recreated
			at every request and Rivet templates (.rvt files) are executed within it. So,
			unless your fully qualifying variable names outside the <command>::request</command> 
			namespace, every variable and procedure created in .rvt files is by default place in
			it and deleted before any other requests gets processed. It is therefore safe to
			create variables or object instances in template files and foresake about them: Rivet
			will take care of cleaning the namespace up. 
		</para>
	</simplesect>
</section>